# 打小抄

``` python
intervals.sort(key= lambda x: x[0])

l = [3, 2, 3, 7, 8, 1]
l.count(3) 
2
l.index(7)
3
l.reverse()
l
[1, 8, 7, 3, 2, 3]
l.sort()
l
[1, 2, 3, 3, 7, 8]

tup = (3, 2, 3, 7, 8, 1)
tup.count(3)
2
tup.index(7)
3
list(reversed(tup))
[1, 8, 7, 3, 2, 3]
sorted(tup)
[1, 2, 3, 3, 7, 8]


# 堆的用法
import heapq
free_rooms = []
heapq.heappush(free_rooms, intervals[0][1])
heapq.heappop(free_rooms)
heapq.heapify([])

# 字符串相关
sorted("acb")
# ['a', 'b', 'c']
ord(c)
reversed([1,2,3])
reversed("abc")
 'a'.isalpha()
  ','.isalnum()
'4'.isdigit()

# 数值相关
-float('inf'), float('inf')


# 位运算
class Solution2:
    def hasAlternatingBits(self, n: int) -> bool:
        tmp = n^(n>>1)
        return tmp&(tmp+1) == 0

# 排序相关
intervals.sort(key=lambda x: x[0])

s.append(chr(ord(i) + 32))


sorted(counter.items(), key=lambda x: (x[1], -x[0]))
nums.sort(reverse=True)

intervals = [[3,1],[2,3],[2,1]]
intervals.sort(key=lambda x: (x[0], x[1]))

# 前序遍历
class Solution:
    def preorderTraversal(self, root: TreeNode) -> List[int]:
        if not root: return []
        res, stack = [], [root]
        while stack:
            tmp = stack.pop()
            res.append(tmp.val)
            if tmp.right:
                stack.append(tmp.right)
            if tmp.left:
                stack.append(tmp.left)
        return res

# 中序遍历
class Solution:
    def inorderTraversal(self, root: TreeNode) -> List[int]:
        stack, res = [], []
        while stack or root:
            if root:
                stack.append(root)
                root = root.left
            else:
                tmp = stack.pop()
                res.append(tmp.val)
                root = tmp.right
        return res

any([True, False])
all([True, False])

del dic[1]
if dic:
    pass
min(dic), 键的最小值

```


紧急整理
- 用栈实现中序遍历


回溯法的经验
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return
    
    for 选择 in 选择列表:
        做选择
        backtrack(路径, 选择列表)
        撤销选择


快速排序
归并排序

数据流的中位数
零钱兑换
三数之和

